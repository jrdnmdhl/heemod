#' Evaluate Strategy
#' 
#' Given an unevaluated strategy, an initial number of 
#' individual and a number of cycle to compute, returns the 
#' evaluated version of the objects and the count of 
#' individual per state per model cycle.
#' 
#' `init` need not be integer. E.g. `c(A = 1, B = 0.5, C =
#' 0.1, ...)`.
#' 
#' @param strategy An `uneval_strategy` object.
#' @param parameters Optional. An object generated by 
#'   [define_parameters()].
#' @param cycles positive integer. Number of Markov Cycles 
#'   to compute.
#' @param init numeric vector, same length as number of 
#'   model states. Number of individuals in each model state
#'   at the beginning.
#' @param method Counting method.
#' @param expand_limit A named vector of state expansion 
#'   limits.
#' @param inflow Numeric vector, similar to `init`. Number
#'   of new individuals in each state per cycle.
#' @param strategy_name Name of the strategy.
#'   
#' @return An `eval_strategy` object (actually a list of 
#'   evaluated parameters, matrix, states and cycles 
#'   counts).
#'   
#' @example inst/examples/example_eval_strategy.R
#'   
#' @keywords internal
eval_strategy <- function(strategy, parameters, cycles, 
                          init, method, expand_limit,
                          inflow, strategy_name) {
  
  stopifnot(
    cycles > 0,
    length(cycles) == 1
  )
  
  states <- get_states(strategy)
  n_states = length(states)
  transitions <- get_transition(strategy)
  
  # Identify which states need to be expanded
  i_params <- interpolate(parameters)
  i_state <- interpolate(states, more = parameters)
  i_trans <- interpolate(transitions, more = parameters)
  state_td <- has_state_time(i_state)
  mat_td <- has_state_time(i_trans) %>%
    matrix(nrow = n_states, ncol = n_states, byrow = TRUE) %>%
    apply(1, any)
  to_expand <- state_td | mat_td
  expand_table <- tibble::tibble(
    state = attr(states, "names"),
    expand = to_expand,
    limit = ifelse(to_expand, expand_limit, 1)
  )
  
  # Evaluate parameters
  e_parameters <- eval_parameters(
    parameters,
    cycles = cycles,
    strategy_name = strategy_name,
    max_state_time = max(expand_limit)
  )
  
  # Inits
  e_init <- eval_init(
    init,
    e_parameters,
    expand_table
  )
  
  # Inflow
  e_inflow <- eval_inflow(
    inflow,
    e_parameters,
    expand_table
  )
  
  # Evaluate States
  e_states <- eval_state_list(
    get_states(strategy),
    e_parameters,
    expand_table
  )
  
  # Evaluate Transitions
  e_transition <- eval_transition(
    get_transition(strategy),
    e_parameters,
    expand_table
  )
  
  count_table <- compute_counts(
    x = e_transition,
    init = e_init,
    inflow = e_inflow,
    expand = expand_table
  ) %>% 
    correct_counts(method = method)
  
  values <- compute_values(e_states, count_table)
  
  n_indiv <- sum(e_init[1, ], e_inflow[1, ])
  
  structure(
    list(
      parameters = e_parameters,
      transition = e_transition,
      states = e_states,
      counts = count_table,
      values = values,
      init = e_init,
      inflow = e_inflow,
      n_indiv = n_indiv,
      cycles = cycles,
      expand_limit = expand_limit
    ),
    class = c("eval_strategy")
  )
}

get_eval_init <- function(x) {
  UseMethod("get_eval_init")
}

get_eval_init.eval_strategy <- function(x) {
  x$e_init
}

get_eval_inflow <- function(x) {
  UseMethod("get_eval_inflow")
}

get_eval_inflow.eval_strategy <- function(x) {
  x$e_inflow
}

get_n_indiv <- function(x) {
  UseMethod("get_n_indiv")
}

get_n_indiv.eval_strategy <- function(x) {
  x$n_indiv
}

#' Compute Count of Individual in Each State per Cycle
#' 
#' Given an initial number of individual and an evaluated 
#' transition matrix, returns the number of individual per 
#' state per cycle.
#' 
#' Use the `method` argument to specify if transitions 
#' are supposed to happen at the beginning or the end of 
#' each cycle. Alternatively linear interpolation between 
#' cycles can be performed.
#' 
#' @param x An `eval_matrix` or
#'   `eval_part_surv` object.
#' @param init numeric vector, same length as number of 
#'   model states. Number of individuals in each model state
#'   at the beginning.
#' @param inflow numeric vector, similar to `init`.
#'   Number of new individuals in each state per cycle.
#'   
#' @return A `cycle_counts` object.
#'   
#' @keywords internal
compute_counts <- function(x, ...) {
  UseMethod("compute_counts")
}

#' @export
compute_counts.eval_matrix <- function(x, init, inflow, ...) {
  
  if (! ncol(init) == get_matrix_order(x)) {
    stop(sprintf(
      "Length of 'init' vector (%i) differs from the number of states (%i).",
      length(init),
      get_matrix_order(x)
    ))
  }
  
  if (! ncol(inflow) == get_matrix_order(x)) {
    stop(sprintf(
      "Number of columns of 'inflow' matrix (%i) differs from the number of states (%i).",
      ncol(inflow),
      get_matrix_order(x)
    ))
  }
  
  i <- 0
  add_and_mult <- function(x, y) {
    i <<- i + 1
    print(i)
    (x + unlist(inflow[i, ])) %*% y
  }
  
  list_counts <- Reduce(
    add_and_mult,
    x,
    init,
    accumulate = TRUE
  )
  
  res <- dplyr::as.tbl(
    as.data.frame(
      matrix(
        unlist(list_counts),
        byrow = TRUE,
        ncol = get_matrix_order(x)
      )
    )
  )
  
  colnames(res) <- colnames(init)
  
  structure(res, class = c("cycle_counts", class(res)))
}

#' Compute State Values per Cycle
#' 
#' Given states and counts, computes the total state values 
#' per cycle.
#' 
#' @param states An object of class `eval_state_list`.
#' @param counts An object of class `cycle_counts`.
#'   
#' @return A data.frame of state values, one column per 
#'   state value and one row per cycle.
#'   
#' @keywords internal
## slightly harder to read than the original version, but much faster
## identical results to within a little bit of numerical noise
compute_values <- function(states, counts) {
  
  lapply(states, function(var){
    rowSums(var * counts)
  }) %>%
    do.call(tibble::tibble, .)

}