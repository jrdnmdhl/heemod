#' Evaluate Markov Model States
#' 
#' @param x An `uneval_state_list` object generated by 
#'   [define_state_list()].
#' @param parameters An `eval_parameters` object 
#'   generated by [eval_parameters()].
#'   
#' @return An `eval_states` object, a list with one 
#'   data.frame per state containing a column per state 
#'   value and a line per cycle.
#'   
#' @keywords internal
eval_state_list <- function(x, parameters, expand) {
  
  # Set up time values for which state values will be evaluated
  time_values <- list(
    state_time = parameters$state_time,
    model_time = parameters$model_time
  )
  
  # Set up empty tibble for variable values
  vars_df <- tibble::tibble()
  
  # Get number of states and names
  n_states <- length(x)
  state_names <- names(x)
  
  # Loop through variables in each state and add to table
  for(i in seq_len(n_states)) {
    
    # Get number of variables and names
    n_var <- length(x[[i]])
    var_names <- names(x[[i]])
    for(j in seq_len(n_var)) {
      
      # Evaluate and add to table
      state_values <- time_values
      state_values$.state <- state_names[i]
      state_values$.name <- var_names[j]
      state_values$.value <- lazyeval::lazy_eval(
        x[[i]][[j]],
        data = parameters
      )
      vars_df <- rbind(
        vars_df,
        do.call(tibble::tibble, state_values)
      )
      
    }
  }
  
  # Handle expansion
  vars_df <- vars_df %>%
    dplyr::left_join(expand, by = c(".state" =  "state")) %>%
    dplyr::filter(state_time <= limit) %>%
    dplyr::mutate(
      .full_state = ifelse(expand, paste0(".", .state, "_", state_time), .state)
    )
  
  
  
  # Recast to matrix
  all_var_names <- unique(vars_df$.name)
  all_state_names <- unique(vars_df$.full_state)
  var_mat <- vars_df %>%
    reshape2::acast(
      factor(.name, levels = all_var_names) ~
        model_time ~
        factor(.full_state, levels = all_state_names),
      value.var = ".value",
      fill = 0
    )
  
  # Split into named list by variable
  var_mat_list <- split_along_dim(var_mat, 1)
  names(var_mat_list) <- all_var_names
  
  structure(
    var_mat_list,
    class = c("eval_state_list", class(var_mat_list))
  )
}

eval_single_state <- function(x, parameters, expand) {
  
  
  # Get number of variables and state names
  n_var <- nrow(expand)
  state_names <- names(x)
  
  # Start a blank df
  inflow_df <- tibble::tibble()
  
  # Evaluate initial values
  for(i in seq_len(n_state)) {
    inflow_df <- rbind(
      inflow_df,
      tibble::tibble(
        .name = state_names[i],
        model_time = parameters$model_time,
        state_time = parameters$state_time,
        .value = lazyeval::lazy_eval(x[[i]],data = parameters)
      )
    )
  }
  
  # Expand and Transpose
  inflow_df <- inflow_df %>%
    left_join(expand, by = c(".name" = "state")) %>%
    dplyr::filter(state_time <= limit) %>%
    dplyr::mutate(
      .full_name = ifelse(
        expand,
        paste0(".", .name, "_", state_time),
        .name
      ),
      .value = ifelse(state_time == 1, .value, 0)
    ) %>%
    reshape2::acast(model_time~factor(.full_name, levels=unique(.full_name)), value.var = ".value")
  
}

get_state_value_names.eval_state_list <- function(x){
  names(x[[1]])[-1]
}

#' Hack to Work Around a Discounting Issue
#' 
#' This function is a hack to avoid a problem with 
#' discounting when the argument is a constant.
#' 
#' The hack consists in replacing calls to
#' `discount(x)` by `discount(x * rep(1, n()))` to
#' ensure `x` is recycled to the correct length.
#' 
#' @param .dots A state object.
#'   
#' @return A modified state object.
#'   
#' @keywords internal
discount_hack <- function(.dots) {
  f <- function (x, env) {
    if (is.atomic(x) || is.name(x)) {
      x
    } else if (is.call(x)) {
      if (discount_check(x[[1]], env)) {
        x <- pryr::standardise_call(x)
        x$x <- substitute((.x * rep(x = 1, times = n())), list(.x = x$x))
      }
      as.call(lapply(x, f, env = env))
    } else if (is.pairlist(x)) {
      as.pairlist(lapply(x, f, env = env))
    } else {
      stop(sprintf(
        "Don't know how to handle type %s.",
        typeof(x)))
    }
  }
  
  do.call(
    structure,
    c(list(
      .Data = lapply(
        .dots,
        function(x) {
          x$expr <- f(x$expr, env = x$env)
          x
        }
      )),
      attributes(.dots)
    )
  )
}

# Ensure only heemod version of discount gets used
discount_check <- function(x, env) {
  if (identical(x, quote(discount)) ||
      identical(x, quote(heemod::discount))) {
    if (identical(x, quote(heemod::discount)) &&
        (utils::packageVersion("dplyr") <= "0.5" ||
         utils::packageVersion("lazyeval") <= "0.2")) {
      warning("Install the development version of 'lazyeval' and 'dplyr' ",
              'to avoid the error \'could not find function "n"\'.')
    }
    if (identical(environment(eval(x, envir = env)),
                  asNamespace("heemod"))) {
      TRUE
    } else {
      warning("A version of 'discount()' that is not defined by heemod was found.")
      FALSE
    }
  } else {
    FALSE
  }
}
